# 并发编程

## 8. 共享模型之工具

### 8.1 线程池

#### 1.自定义线程池

#### 2.ThreadPoolExecutor

![image-20220603213115117](./images/image-20220603213115117.png)

##### 1）线程池状态

ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量

| 状态名     | 高 3位 | 接收新任务 | 处理阻塞队列任务 | 说明                                      |
| ---------- | ------ | ---------- | ---------------- | ----------------------------------------- |
| RUNNING    | 111    | Y          | Y                |                                           |
| SHUTDOWN   | 000    | N          | Y                | 不会接收新任务，但会处理阻塞队列剩余任务  |
| STOP       | 001    | N          | N                | 会中断正在执行的任务，并抛弃阻塞队列任务  |
| TIDYING    | 010    | -          | -                | 任务全执行完毕，活动线程为 0 即将进入终结 |
| TERMINATED | 011    | -          | -                | 终结状态                                  |

从数字上比较，TERMINATED > TIDYING > STOP > SHUTDOWN > RUNNING
这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作进行赋值

```java
// c 为旧值， ctlOf 返回结果为新值
ctl.compareAndSet(c,ctlOf(targetState,workerCountOf(c))));
// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们
private static int ctlOf(int rs,int wc){return rs|wc;}
```

##### 2）构造方法

```java
    public ThreadPoolExecutor(int corePoolSize,
        int maximumPoolSize,
        long keepAliveTime,
        TimeUnit unit,
        BlockingQueue<Runnable> workQueue,
        ThreadFactory threadFactory,
        RejectedExecutionHandler handler) 
```

- corePoolSize 核心线程数目 (最多保留的线程数)
- maximumPoolSize 最大线程数目
- keepAliveTime 生存时间 - 针对救急线程
- unit 时间单位 - 针对救急线程
- workQueue 阻塞队列
- threadFactory 线程工厂 - 可以为线程创建时起个好名字
- handler 拒绝策略

工作方式：

![image-20220603221234446](./images/image-20220603221234446.png)

- 线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。

- 当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程。

- 如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。

- 如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 4 种实现，其它著名框架也提供了实现

  - AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略
  - CallerRunsPolicy 让调用者运行任务
  - DiscardPolicy 放弃本次任务
  - DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之
  - Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题
  - Netty 的实现，是创建一个新线程来执行任务
  - ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略
  - PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略

- 当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由keepAliveTime 和 unit 来控制。

  ![image-20220603222838520](./images/image-20220603222838520.png)

  根据这个构造方法，JDK Executors 类中提供了众多工厂方法来创建各种用途的线程池

##### 3）newFixedThreadPool

```java
public static ExecutorService newFixedThreadPool(int nThreads){
        return new ThreadPoolExecutor(nThreads,nThreads,
        0L,TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>());
        }
```

特点

- 核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间
- 阻塞队列是无界的，可以放任意数量的任务

> **评价**：适用于任务量已知，相对耗时的任务

```java
ExecutorService executorService=Executors.newFixedThreadPool(10);
```

##### 4）newCachedThreadPool

```java
public static ExecutorService newCachedThreadPool(){
        return new ThreadPoolExecutor(0,Integer.MAX_VALUE,
        60L,TimeUnit.SECONDS,
        new SynchronousQueue<Runnable>());
        }
```

特点

- 核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着

  - 全部都是救急线程（60s 后可以回收）
  - 救急线程可以无限创建

- 队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）

  - ```java
    SynchronousQueue<Integer> synchronousQueue = new SynchronousQueue<>();
    
            new Thread(() -> {
                try {
                    log.info("put 1");
                    synchronousQueue.put(1);
                    log.info("put 1 success");
    
                    log.info("put 2");
                    synchronousQueue.put(2);
                    log.info("put 2 success");
    
                    log.info("put 3");
                    synchronousQueue.put(3);
                    log.info("put 3 success");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }).start();
    
            Thread.sleep(1000);
    
            new Thread(() -> {
                try {
                    log.info("take");
                    Integer i = synchronousQueue.take();
                    log.info("take {} success",i);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }).start();
    
            Thread.sleep(1000);
    
            new Thread(() -> {
                try {
                    log.info("take");
                    Integer i = synchronousQueue.take();
                    log.info("take {} success",i);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }).start();
    
            Thread.sleep(1000);
    
            new Thread(() -> {
                try {
                    log.info("take");
                    Integer i = synchronousQueue.take();
                    log.info("take {} success",i);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }).start();
    ```

      输出

      ```java
      16:04:53.220 [Thread-0] INFO cn.liyohe.juc.chapter8.CachedThreadPoolMain - put 1
      16:04:54.201 [Thread-1] INFO cn.liyohe.juc.chapter8.CachedThreadPoolMain - take
      16:04:54.201 [Thread-0] INFO cn.liyohe.juc.chapter8.CachedThreadPoolMain - put 1 success
      16:04:54.202 [Thread-0] INFO cn.liyohe.juc.chapter8.CachedThreadPoolMain - put 2
      16:04:54.201 [Thread-1] INFO cn.liyohe.juc.chapter8.CachedThreadPoolMain - take 1 success
      16:04:55.204 [Thread-2] INFO cn.liyohe.juc.chapter8.CachedThreadPoolMain - take
      16:04:55.204 [Thread-2] INFO cn.liyohe.juc.chapter8.CachedThreadPoolMain - take 2 success
      16:04:55.204 [Thread-0] INFO cn.liyohe.juc.chapter8.CachedThreadPoolMain - put 2 success
      16:04:55.204 [Thread-0] INFO cn.liyohe.juc.chapter8.CachedThreadPoolMain - put 3
      16:04:56.204 [Thread-3] INFO cn.liyohe.juc.chapter8.CachedThreadPoolMain - take
      16:04:56.204 [Thread-3] INFO cn.liyohe.juc.chapter8.CachedThreadPoolMain - take 3 success
      16:04:56.204 [Thread-0] INFO cn.liyohe.juc.chapter8.CachedThreadPoolMain - put 3 success
      ```

      > **评价**：整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。 适合任务数比较密集，但每个任务执行时间较短的情况

##### 5）newSingleThreadPool

```java
public static ExecutorService newSingleThreadExecutor(){
        return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1,1,
        0L,TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>()));
        }
```

使用场景

希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。

区别：

- 自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作
- Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改
  - FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法
- xecutors.newFixedThreadPool(1) 初始时为1，以后还可以修改
  - 对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setzhCorePoolSize 等方法进行修改

##### 6）提交任务

```java
// 执行任务
void execute(Runnable command);

// 提交任务 task 用返回值 Future 获得执行结果
<T> Future<T> submit(Runnable<T> task);

// 提交 Task 中所有任务
<T> List<Future<T>>invokeAll(Collection<?extends Callable<T>> tasks)
        throws InterruptedException;

// 提交 Task 中所有任务，带超时时间
<T> List<Future<T>>invokeAll(Collection<?extends Callable<T>> tasks,
        long timeout,TimeUnit unit)
        throws InterruptedException;

// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消
<T> T invokeAny(Collection<?extends Callable<T>> tasks)
        throws InterruptedException,ExecutionException;

// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间
<T> T invokeAny(Collection<?extends Callable<T>> tasks,
        long timeout,TimeUnit unit)
        throws InterruptedException,ExecutionException,TimeoutException;
```

##### 7）关闭线程池

**shutdown**

```java
/*
线程池状态变为 SHUTDOWN
- 不会接收新任务
- 但已提交任务会执行完
- 此方法不会阻塞调用线程的执行
*/
void shutdown();
```

```java
public void shutdown(){
final ReentrantLock mainLock=this.mainLock;
        mainLock.lock();
        try{
        checkShutdownAccess();
        // 修改线程池状态
        advanceRunState(SHUTDOWN);
        // 仅打断空闲线程
        interruptIdleWorkers();
        onShutdown(); // hook for ScheduledThreadPoolExecutor
        }finally{
        mainLock.unlock();
        }
        tryTerminate();
        }
```

**shutdownNow**

```java
/*
线程池状态变为 STOP
- 不会接收新任务
- 会将队列中的任务返回
- 并用 interrupt 的方式中断正在执行的任务
*/
List<Runnable> shutdownNow();
```

```java
public List<Runnable> shutdownNow(){
        List<Runnable> tasks;
final ReentrantLock mainLock=this.mainLock;
        mainLock.lock();
        try{
        checkShutdownAccess();
        // 修改线程池状态
        advanceRunState(STOP);
        // 打断所有线程
        interruptWorkers();
        // 获取队列中剩余的任务
        tasks=drainQueue();
        }finally{
        mainLock.unlock();
        }
        // 尝试终结
        tryTerminate();
        return tasks;
        }
```

#####    * 模式-Worker Thread

##### 8）任务调度线程池

##### 9）正确处理执行任务异常

#####    * 应用之定时任务

##### 10）Tomcat线程池

#### 3.Fork/Join

##### 1）概念

##### 2）使用

### 8.2 J.U.C

#### 1.*AQS原理

##### 1.1概述

全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架

特点：

- 用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取
  锁和释放锁
  - getState - 获取 state 状态
  - setState - 设置 state 状态
  - compareAndSetState - cas 机制设置 state 状态
  - 独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源
- 提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList
- 条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet

子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）

- tryAcquire
- tryRelease
- tryAcquireShared
- tryReleaseShared
- isHeldExclusively

获取锁的姿势

```java
// 如果获取锁失败
if(!tryAcquire(arg)){
// 入队, 可以选择阻塞当前线程 park unpark
        }
```

释放锁的姿势

```java
// 如果释放锁成功
if(tryRelease(arg)){
// 让阻塞线程恢复运行
        }
```

##### 2.2 实现不可重入锁

**自定义同步器**

##### 3.3 心得

###### 起源

​ 早期程序员会自己通过一种同步器去实现另一种相近的同步器，例如用可重入锁去实现信号量，或反之。这显然不够优雅，于是在 JSR166（java 规范提案）中创建了 AQS，提供了这种通用的同步器机制。

###### 目标

AQS 要实现的功能目标

- 阻塞版本获取锁 acquire 和非阻塞的版本尝试获取锁 tryAcquire
- 获取锁超时机制
- 通过打断取消机制
- 独占机制及共享机制
- 条件不满足时的等待机制

要实现的性能目标

> Instead, the primary performance goal here is scalability: to predictably maintain efficiency even, or
> especially, when synchronizers are contended

###### 设计

AQS 的基本思想其实很简单

获取锁的逻辑

```java
while(state 状态不允许获取){
        if(队列中还没有此线程){
        入队并阻塞
        }
        }
        当前线程出队
```

释放锁的逻辑

```java
if(state 状态允许了){
        恢复阻塞的线程(s)
        }
```

要点

- 原子维护 state 状态
- 阻塞及恢复线程
- 维护队列

**1） state 设计**

**2） 阻塞恢复设计**

**3） 队列设计**

**主要用到 AQS 的并发工具类**

#### 2.*ReentranLock原理

#### 3.读写锁

##### 3.1ReentrantReadWriteLock

​ 当读操作远远高于写操作时，这时候使用 `读写锁` 让 `读-读` 可以并发，提高性能。 类似于数据库中的 `select ...from ... lock in share mode`
​ 提供一个 `数据容器类` 内部分别使用读锁保护数据的 `read()` 方法，写锁保护数据的 `write()` 方法

#### 4.Semaphore

#### 5.CountdownLatch

#### 6.CyclicBarrier

#### 7.线程安全集合类概述

#### 8.ConcurrentHashMap

#### 9.BlockingQueue

#### 10.ConcurrentLinkedQueue

#### 11.CopyOnWriteArrayList

